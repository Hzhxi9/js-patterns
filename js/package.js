/**
 * 封装
 *
 * 1. 目的
 *    - 将信息隐藏, 封装应该被视为 "任何形式的封装"
 *    - 封装不仅仅是隐藏数据、还包括隐藏实现细节, 设计细节以及隐藏对象的类型等  
 * 
 * 2. 分类: 封装数据、封装实现、封装类型、封装变化
 */

/**
 * 封装数据
 * 
 * 1. 封装数据是由语法解析来实现的, 提供了 private、public、protected 等关键字来提供不同的访问权限
 * 2. 但 JavaScript 没有提供这些关键字的支持, 只能依赖变量的作用域来实现封装特性, 而且只能模拟出 public、 private 这两种封装性
 * 3. 创建作用域
 *      - let、const
 *      - 通过函数
 *      - Symbol 创建私有属性
 **/
var o = (function () {
  var _name = 'name'; // 私有 (private) 变量
  return {
    getName: function () {
      return _name; // 公开 (public) 变量
    },
  };
})();

console.log(o.name); // undefined
console.log(o.getName()) // name

/**
 * 封装实现
 * 
 *   - 封装使得对象内部的变化对其他对象而言是透明的, 也就是不可见的
 *   - 对象对自己的行为负责
 *   - 其他对象或者用户都不关心它的内部实现
 *   - 封装使得对象之间的耦合变松散, 对象之间只通过暴露的 API 接口来通信
 *   - 当我们修改一个对象时, 可以随意地修改它的内部实现, 只要对外的接口没有变化, 就不会影响到程序的其他功能
 */


/**
 * 封装类型
 * 
 *   - 封装类型是静态类型语言中一种重要的封装方式
 *   - 封装类型是通过抽象类和接口来进行的
 *   - 把对象的真正类型隐藏在抽象类或者接口之后, 相比对象的类型, 客户更关心对象的行为
 */

/**
 * 封装变化
 * 
 *   《设计模式》总结了23种设计模式
 *      - 从意图上区分为三种模式
 *         - 创建型模式: 要创建一个对象, 是一种抽象行为, 而具体创建什么对象则是可以变化的, 目的就是封装创建对象的变化
 *         - 结构型模式: 封装对象之间的组合关系
 *         - 行为型模式  对象的行为变化
 * 
 *    通过封装的方式, 把系统中稳定不变的部分和容易变化的部分隔离开来
 *    在系统的演变过程中, 只需要替换那些容易变化的部分, 如果这些部分是已经封装好的, 替换起来也相对容易 
 */