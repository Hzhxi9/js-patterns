# JavaScript 设计模式

## 书写可维护的代码

### 什么叫可维护代码

1. 可读性
2. 一致性
3. 可预测性
4. 看上去就像是同一个人写的
5. 已记录

### 最小全局变量

javascript 通过函数管理作用域

1. 在函数内部声明的变量只在这个函数内部, 函数外部不可用

2. 全局变量就是在任何函数外面声明的或是未声明直接简单使用的

每个 JavaScript 环境有一个全局对象, 当你在任意的函数外部使用 this 的时候可以访问到

你创建的每一个全部变量都成了这个全局对象的属性

在浏览器中, 该全局对象有个附加属性叫做 Window, 此 window(通常)指向该全局对象本身

```js
/**如何在浏览器环境中创建和访问全局变量 */

global = 'hello'; // 不推荐写法
console.log(global); // hello
console.log(window.global); // hello
console.log(window['global']); // hello
console.log(this.global); // hello
```

### 全局变量的问题

你的 JavaScript 应用程序和 web 页面上的所有代码都会共享这些全局变量, 他们会共同存在同一个全局命名空间, 所以当程序的两个不同部分定义同名但不同作用的全局变量的时候, 命名冲突在所难免。

web 页面包含不是该页面开发者所写的代码也是比较常见的, 比如:

- 第三方 JavaScript 库
- 广告方的脚本代码
- 第三方用户追踪和分析脚本代码
- 不同类型的小组件、标志和按钮

JavaScript 的两个特性, 会不自觉创建出全局变量

- 不需要声明就可以使用变量
- JavaScript 有隐含的全局概念, 意味着你不声明的任何变量都会成为一个全局对象属性

```js
// 不推荐写法: 隐式全局变量
function sum(x, y) {
  result = x + y;
  return result;
}
```

result 没有声明, 代码照样运作正常, 但在调用函数后, 你最后的结果就多一个全局命名空间

```js
// 修复方案: 始终使用var声明变量
function sum(x, y) {
  var result = x + y;
  return result;
}
```

另一种创建隐式全局变量的反例就是使用任务链进行部分 var 声明

```js
// 反例: a 是局部变量, b 是全局变量
function foo() {
  // 原因: 这个从右到左的赋值
  // 首先是赋值表达式 b = 0, 此情况下b 是未声明的。
  // 这个表达式的返回值是0
  // 然后这个0就分配给了通过 var 定义的这个局部变量 a
  var a = b = 0; // 等同与 var a = (b = 0);
}
```

```js
// 准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量
function foo() {
  var a, b;
  a = b = 0; // 两个均为局部变量
}
```
